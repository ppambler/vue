### ✍️ Tangxt ⏳ 2020-09-29 🏷️ vuex

# 12-Vue 全局数据管理（下）之 Vuex

## ★Vuex 初体验 - 数据读写

![全局数据管理](assets/img/2020-09-29-11-50-05.png)

1）安装

安装 `vuex` （在创建项目的时候我们已经安装了），如果没有那就 `npm` 一下呗！

2）是什么？

![是什么](assets/img/2020-09-29-13-18-13.png)

我们在写文章的时候 -> 记住不要用那么多术语

话又说回来，我们该如何理解 vuex 是什么呢？

用之前我们弄得 `store` 来理解它 -> **用来管理数据的工具**！ -> 简单来说，它就是个对象，提供了一些 API，让我们可以读数据（查）和写数据（增删改）！

总之，所谓「管理」就是「读写」，所谓「状态」就是「数据」! -> 「状态管理模式」即是「**数据读写工具**」（关于「模式」的解释，芳芳也不知道是什么意思……）

3）我们能否透过官方提供的视频学会 vuex ？

> [视频 1](https://vuex.vuejs.org/)、[视频 2](https://scrimba.com/scrim/cMPa2Uk?pl=pnyzgAP)

![vuex](assets/img/2020-09-29-13-37-31.png)

很难 -> 因为对于中国人而言，它是英文教学的 -> 所以我们只好用 CRM 大法看官方文档学习它了！

> 很多时候我们学不会某个东西，并不是因为我们的智商问题，而是入门教程实在太辣鸡了！

💡：`store`可不是那个参数`{}`？

![store](assets/img/2020-09-29-16-43-34.png)

我们传的`state`显然是复制到了`store`这个实例上！ -> 跟我们之前`...tagStore`一样……

💡：你以为在`state`里边不能写方法吗？

![方法也可写](assets/img/2020-09-29-17-00-28.png)

💡：读写状态的操作？

- 读：`store.state.count`
- 写：对数据进行改动，需要在`mutations`（改动之意）里边做！

> `data`即是`state`，`methods`即是`mutations` -> Vue 很贱，总是发明一些新的单词来增加我们的记忆负担！ -> 其实是延用了某些设计才搞得这些新单词！

进一步分析一下「写」：

![不要用 this](assets/img/2020-09-29-17-05-29.png)

> `this`可能是`window`

不要用`this`哈，如果你用了，那也是白用了！ -> 传个`state`形参，然后`state.count += 1`这样改！

如何调用`increment`方法？

显然不会用这种智障姿势：

``` js
store.mutations.increment(store.state)
```

vuex 给我们封装了一个 API：

``` js
// 不需要我们自己传 state 参数！
store.commit('increment')
```

> 讽刺：Vuex 给了我们非常多的新单词，但这些单词只是换汤不换药！ -> 本来数据叫`data`的，现在则是叫`state`，本来改变数据直接调用`increment`就好了，但现在不能直接调，而是透过`commit`提交一下`'increment'`方法名来调！

💡：vuex 真得比我们之前封装的`store`好用吗？

![store](assets/img/2020-09-29-17-15-00.png)

没有好用到哪儿去！ -> vuex 改变了我们操作数据的姿势！

💡：如何给`mutation`传参？（如何给改动数据的 API 传参？）

![传参](assets/img/2020-09-29-17-18-42.png)

有的时候，如果你代码写得不好，那么你就去发明概念，你概念发明好了，然后写一些非常简单的库，也可以让这些「简单的」库看起来变得非常牛逼！

> 我很菜，但我可以捣鼓一些你不懂的概念，让我看起来很牛逼，很高级！

💡：单一状态树是什么？

简单来说就是对象（包含了全部的应用层级状态）

``` js
{
  state: {
    count: 0,
    user: {
      name: 'frank',
      age: 18
    }
  }
}
```

所谓的树 -> 数据的嵌套层级很深，看起来像是一棵树！

应用层级状态 -> 应用就是「你的这个项目」、层级就是「一层层的组件」，毕竟一个项目是由很多个组件组合而成的、状态即「数据」 -> 合起来就是「**你的项目里边所有组件的数据**」 -> 不说人话的解释就是「应用层级状态」

唯一数据源 -> 我们整个应用没有第二个数据，那就叫做唯一数据源！

> 为了权威性，所以增加了很多术语，但其实没啥用呀！ -> 真正学习编程，一定要了解这个东西的本质才行！ -> `store`本质就是一个对象！

💡：单一状态树让我们能够直接地定位任一特定的状态片段？

我们可以获取全局对象里边的任意一个数据片段，如`count`等

💡：单状态树和模块化并不冲突？

![模块化](assets/img/2020-09-29-19-13-19.png)

就是分文件呗！

💡：如何在组件中获取状态？

需要计算属性 -> 计算属性写在`@Component`这个装饰器里边！

![computed](assets/img/2020-09-29-19-42-57.png)

如果你只想用一次，那就用`data`姿势呗！但大部分情况都不止用一次哈！

总之，`count`会计算依赖 -> `store.state.count`变了，那么`count`就会变！

💡：`template`里边可以拿到`import`的`store`吗？

![不能](assets/img/2020-09-29-19-48-51.png)

如何解决？

很简单，你改成是一个函数名不就行了：

![做法](assets/img/2020-09-29-19-50-10.png)

另一种解决姿势：

![代码](assets/img/2020-09-29-19-52-38.png)

`Vue.use(Vuex)`这行代码，`use`操作会去调用`Vuex`里边的一些东西，这些东西会在`Vue`的原型上绑定一些共用属性！

`Vue.use(Vuex)`就是在安装这个`Vuex`插件，也就是为`Vue.prototype`挂载一个`$store`属性！ -> 也就是把 `store` 给绑定了： `Vue.prototype.$store = store`

当我们：

``` js
new Vue({
  router,
  store,
  render: (h) => h(App),
}).$mount("#app");
```

这样做时，就是传一个`store`给`$store`了！

话说，为啥不在`index.ts`里边一开始就传了？而是跑去`main.ts`里边传？ -> 就是这样设计的！因为符合初始化语法哈！ -> 相当于是注册了，要初始化才能使用！

所以另一种姿势就这样这样：

![另一种姿势](assets/img/2020-09-29-20-11-03.png)

4）小结

- 读的时候用`computed`来获取 -> `computed:{ count() { return this.$store.state.count } }`
- 写的时候用`this.$store.commit`或者是`this.store.commit`

使用`$store`不需要我们`import` `store`

对比我们之前写的自定义`store`，vuex 并没有好在哪里，而且很不简洁！（**很复杂**） -> 也比不上那种`window`姿势！ -> 明明使用 vuex 没有好处，为啥还要学呢？ -> 因为大家都在学呗！ -> 前端的整体水平有待提高，毕竟什么是好处，什么是坏处，一点深刻认识都没有！

> 批判一个东西前先学会它，不然，别人是不信你所说的！

## ★在 Money.vue 中使用 Vuex

