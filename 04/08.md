### ✍️ Tangxt ⏳ 2020-08-27 🏷️ Money 组件

# Money.vue 组件（下）

## ★JS 组件

> 先用 JS 的姿势来写，写完后再改写成 TS 姿势的！

1）「收入」&「支出」类型切换组件

刚开始搞，就来整个最简单的！

在单文件组件里边，写 JS 区域的模板：

``` html
<script>
  export default { data, props, methods, created, /**...**/ }
</script>

<!-- <=> -->

<script lang="js">
  export default { data, props, methods, created, /**...**/ }
</script>
```

> 你不写`lang="js"`，默认就是 `lang="js"`！

思路：

1. 定义这个切换组件的状态：`type`为`'+'/'-'`则表示组件为「收入/支出」状态 -> 定义组件状态用 `data`
2. 在`template`里边代表「支出」和「收入」的这俩元素，此时 `type` 为何值，那么相对应的谁就有下划线，也就是谁会有 `selected` 这个 class
3. 组件状态的改变 -> `click` 元素

代码：[Demo](https://github.com/ppambler/vue-morney/commit/8425cd2198778b2a1dddbb2a629e234a499820ba)

2）代码分析

`:class="type === '-' && 'selected'"`：

![咩有一个叫 false 的 class](assets/img/2020-08-30-19-28-59.png)

vue 在背后做了很多事情，如果 `&&` 表达式返回了 `false`，那么 vue 就会自动把这个 `false` 值给去掉，毕竟 class 是 `false` 未免也显得忒奇怪了吧！ -> 总之，这是一种**简写的写法**！正常写法应该是整个三目运算……

`@click="selectType('-')"`：

这还有一种写法，那就是直接 `type = '-'`就可以了，但是这种写法**只能写一行代码**，所以这就显得很鸡肋了！而方法调用则可以**写多行代码**！

该「切换组件（`Types`）」接收外边传过来的值：

透过 `props` 这个 options API 就可以做到！ -> 拿到传过来的值，一般扔到 `mounted` 里边使用！

![如何看 `props`？](assets/img/2020-08-30-19-50-39.png)

---

接下来看看如何把上边的 JS 代码，改成是 TS 姿势的！

## ★TS 组件

> 实现第一个 TS Vue 组件

![如何写一个 TS 组件？](assets/img/2020-08-31-13-56-10.png)

1）TS 组件 vs JS 组件

它们俩最大的不同：

TS 组件不用构造选项 -> 为啥不用？ -> 因为构造选项是没有类型的，而且可以随便加东西！

写 TS 组件必须要用 `Class` -> 这是 Vue 规定的！

2）如何写一个 TS 组件？

1. 为 `<script>` 添加 `lang="ts"`
2. 导出一个 `class`，而且该 `class` 继承 `Vue` -> 这是规定
3. 在 `class` 里边定义实例的自有属性 -> 就是在干 `data` 的活儿
4. 在 `class` 里边定义实例的方法 -> 就是在干 `methods` 的活儿
5. 安装`vue-property-decorator`：`npm i -S vue-property-decorator` -> 在安装`vue-property-decorator`的过程中，连带着`vue-class-component`也一起安装了！
6. 添加装饰器 `@Component` -> 有了它，就可以把「自有属性+实例方法」自动处理成「`data`+`methods`」了 -> 没有它，那就不帮你处理了！ -> **总之，它是一个自动化的帮我们处理代码的东西**
7. 为 JS 代码加类型 -> 你用 webstorm，如果代码出现爆红，那么你就得把它去处理成不爆红的状态！ 如：为形参加类型 `selectType(type: string) {}`（是小写的`string`，可不是大写的`String`）

> 如何添加生命周期钩子？ -> 直接 `created() {}` 就行了！

代码：

![代码](assets/img/2020-08-31-17-17-06.png)

3）vue-property-decorator

文档：[kaorun343/vue-property-decorator: Vue.js and Property Decorator](https://github.com/kaorun343/vue-property-decorator)

这个包不是尤雨溪写的，话说，为啥不用尤雨溪的呢？ -> 因为尤雨溪写的没有这个人写的好！

尤雨溪写的是这个：[vuejs/vue-class-component: ES / TypeScript decorator for class-style Vue components.](https://github.com/vuejs/vue-class-component) -> 这是 Vue 官方提供的 TS 支持库！但其功能不如 `vue-property-decorator` 好用，所以我们就用了这个 `vue-property-decorator`！

`vue-property-decorator` 提供了好几个装饰器（`@`开头的），当然，我们用的这个 `@Component` 是 Vue 官方提供的！所以，如果你要看 `@Component` 的官方文档，那就得看 `vue-class-component` 的！

透过 CRM 学习法来了解 `@Component` 的使用：

> 文档：[Overview - Vue Class Component](https://class-component.vuejs.org/)

![vue-class-component 使用姿势](assets/img/2020-08-31-14-27-22.png)

> CRM 学习法，让你可以不用深究所有的事情，**节省大量的时间**！当然，你的 JS 基础得扎实才行！ -> 「`class` 语法」 无非就是把 「JS 对象写法」 换成是另一种写法罢了！所以，如果你时间有限的话，其实可以放弃深究 `class` 的语法细节，以及 装饰器的用法！直接依葫芦画瓢就行了，反正你已经知道这种写法的背后到底做了什么……

## ★TS 组件 @Prop 装饰器

1）如何写 props？

![props](assets/img/2020-08-31-18-14-45.png)

Vetur 提示说 `Property 'xxx' does not exist on type 'Types'`（`xxx`不存在于`Types`这个`class`里边！）

可以看到官方文档翻车了……（或许这是插件的缘故！毕竟效果已经出来了，只是插件检测说这有问题罢了！）

代码：[Demo](https://github.com/ppambler/vue-morney/commit/f17179b32b6a7cf40bee969d474467d6f3858f56)

2）用 @Prop 来写 props

![@Prop](assets/img/2020-08-31-18-43-17.png)

你在父组件里边是透过 `xxx="Money pass data"` 来传值的，但这样的写法只能表示这是在传字符串，因此 Vue 报了这样的错误：

![传字符串](assets/img/2020-08-31-18-46-11.png)

> 即便传的值不符合类型，但最终的运行结果还是出来了！ -> Vue 的容错性处理！

所以你得这样来：`:xxx="666"`（加一个`:`，意味着属性值是 JS 代码）

代码：[Demo](https://github.com/ppambler/vue-morney/commit/354969b5caf71a3720b35e23559447c484009864)

3）代码解析

`@Prop(Number) xxx: number | undefined;`：

这行代码在干嘛？为啥写了一个大写的 `Number` 还得再写一个小写的`number`？

`number | undefined` -> 是编译时的检查！ -> 在你还未运行代码的时候就能告诉你的代码是否有问题

如：

![TS 代码检查](assets/img/2020-08-31-19-01-22.png)

透过代码检查，你就明白自己这样写是有潜在的 bug 的！ -> 所以我得换一种写法，如先判断一下 `this.xxx` 是否等于 `undefined`，如果不等于那就证明 `this.xxx` 是个 `Number` 类型的值……

回过头来，整体看一下 `@Prop(Number) xxx: number | undefined;` 这行代码：

- `@Prop`是一个装饰器，告诉 Vue：「后边的这个 `xxx` 属性是个 `prop`，而不是 `data`」 -> **不写 `@Prop` 就是 `data`，写了 `@Prop` 就是 `prop`**
- `Number` -> 告诉 Vue `xxx` **运行时**是个 `Number`，如果不是 `Number` 类型的值，那么浏览器就会报错！
- `xxx` -> 属性名
- `number | undefined` -> 告诉 TS `xxx` 的**编译时**类型 -> 注意，你不写这个`undefined`是会报「`Property 'xxx' has no initializer and is not definitely assigned in the constructor`」这样的错误的！（联合类型通常与 `null` 或 `undefined` 一起使用，给了一个 `undefined` 类型， 就是在告诉 TS `xxx` 的初始值为 `undefined`）

话说，为啥`Number`是大写，而`number` 是小写呢？难道不应该都是小写的吗？

Vue 作者也想把 `Number` 改成是小写的，但因为某种原因（区分运行时和编译时）就放弃了！

![Number vs number](assets/img/2020-08-31-19-38-48.png)

补充一点：

你也可以这样写：`@Prop(Number) xxx: number = 0;`（默认给`xxx`一个`0`的默认值），这样你就不用检查 `xxx` 是否为 `undefined`了，反之，用原先的姿势你就得处处检查`this.xxx`是否为`undefined` -> 我测试了一下给上初始值，结果报了这样的错误：

![给 prop 初始值的 bug](assets/img/2020-08-31-20-04-37.png)

`@Prop(Number) xxx: number | undefined;`这种姿势，应该是在告诉 TS 这个`xxx`是没有初始值的！（疑问 🤔 ） -> 如果父组件不传`xxx`，那么`this.xxx`就是`undefined`值了！这难道不就是在说初始化值是`undefined`吗？

4）我们用 TS 写代码好还是不好？

- 对代码**没追求的**前端 -> 写 TS 就是在打扰他们
- 对代码**有追求的**前端 -> 这东西牛逼呀！我以前没有注意到的错误，它都告诉我了！

给我工资 3k？ -> 我是个没追求的前端，所以我的代码都用 JS 来写 -> 把 `lang="ts"` 删了 + 去掉所有的 `: type1 | type2` -> 瞎写……（webstorm 有智能的编译时弱提示，而 vscode 则没有，只能当代码在浏览器里边跑起来了才知晓！）

给我工资 10k？ -> 那我就是个有追求的前端，因此我的代码应该用 TS 来写！

5）TS 类型添加原则

1. 你这样 `type = '-'` 写了，那么就不用这样写了： `type: string = '-'`，TS 会自己推导
2. 函数的返回值类型声明不用写，即不用 `string selectType(){}` 这样写
3. 函数的形参需要写上类型声明
4. `@Prop(Number) xxx`需要写上类型声明 -> `@Prop(Number) xxx: number | undefined;`

6）怎样理解这个代码？

``` js
this.xxx.yyy
```

`this.xxx`不过关，它可能是 `undefined`，`this.xxx.yyy`不过关，因为已知`this.xxx`是`number`类型，所以它是咩有`yyy`这个方法的

代码改写：

``` js
if(this.xxx === undefined) {
  console.log('xxx is undefined')
} else {
  // xxx 一定会有 toString 这个方法！
  console.log(thix.xxx.toString())
}
```

7）写 TS 的 3 个好处？

1. 类型提示：更智能的提示 -> 自动提示
2. 编译时报错：还没运行代码就知道自己写错了 -> 严谨
3. 类型检查：无法点出错误的属性，如你不能随便写 `this.xxx.yyy`

> 在 Vue 的 `template` 里写的 JS 代码，TS 是不会去检查的！

8）其它装饰器的用法？

自己看 [文档](https://github.com/kaorun343/vue-property-decorator#Prop) -> CRM 学习法！ -> **始终谨记「写法形式上有所不同，不需深究，依葫芦画瓢直接用即可！」**

9）小结

1. 官方的 `props` 不行，就用了第三方的 `@Prop`
2. 搞清楚这行 `@Prop(Number) xxx: number | undefined;` 代码里边的 `Number` 和 `number` 各自代表什么意思！ -> 它们的错误展示是这样的：浏览器控制台 Error（运行时） vs 终端 Error（编译时）

----

## ★TS 的本质

1）TS 真得很难吗？

TS 的本质：

![TS](assets/img/2020-09-01-10-25-34.png)

- TS 的类型 -> 功能是「检测你写的 JS 代码对不对」，如`this.xxx.yyy`，TS 发现`this.xxx`可能是`undefined`，就不让你写`.yyy`了 -> 为啥不让写？ -> 因为这代码在运行时肯定会报错的呀！你想想 `undefined.yyy`？
- TS 检查分两种情况（还有其它情况，这里主要简单提一下类型的变化）：
  - 有错 -> 编译报错 -> 根据「爆红」的线去改你的 JS 代码
  - 没有错 -> 把类型给删了，保留只含有 JS 代码的那部分代码 -> 类型用完就删！
- TS ->编译 -> JS -> babel -> 更低级的 JS
- 谁在做检查？ -> tsc（是一个程序，功能是「检查+编译」，你在安装`typescript`的时候会顺带把这个工具给安装上） -> 对了，babel 也可以做编译这件事儿！ -> 二者都存在独特的功能！
- 编译报错，也能正常运行编译过后的 JS 代码 -> 为啥会这样呢？如果你有一份有 100 行代码的 JS 文件，你直接改成是 `.ts` 后缀，结果编译报了几十处错误，难道我们要一行行改吗？ -> 不需要改，你直接扔到浏览器里跑也是可以正常运行的！所以这就是 TS 它给我们的包容性……

  ![编译报错](assets/img/2020-09-01-13-21-09.png)

- 可以看到，TS 是一个非常简单的东西！ -> 千万不要认为它有多么的难！

2）如何配置只要有编译错误，就无法得到编译出来的 JS 文件？

官网回答说：

在`tsconfig.json`的`"compilerOptions"`配置`"noEmitOnError": true`就行了！

但测试发现，这配置是无效的，TS 还是可以把代码 编译成 JS

当然，我们并不关心这个问题是否能解决，因为这在我看来，这有点画蛇添足的意思了！

3）小结

- TS 的本质，就是在 JS 上写一些 `: 类型`，透过「类型」，我们可以检查我们的 JS 代码是否有错，而检查的家伙是`tsc`这个程序：
  - `tsc`检查通过，就会把 TS 代码翻译成 JS 代码，其中翻译过程中最重要的一步就是把含有`: 类型`这样的代码给删掉，毕竟 JS 本身是不支持 `: 类型` 这种语法的！（翻译出来的 JS 代码是否还需要 Babel 处理呢？不一定需要呀！可能 tsc 就内嵌了类似 Babel 这样的功能，然后自身也顺便把 Babel 的活儿也处理了）
  - `tsc`检查报错，还是可以把 TS 代码翻译成 JS 代码，即直接把 `: 类型`这样的代码给删了就行了 -> 一种**妥协**做法！

---

接下来，就来看看目前写 Vue 单文件组件的几种姿势！

## ★Vue 单文件组件的三种写法

> 只针对「Vue 单文件组件」，可不是直接的在某个 `new Vue({})`里边注册一个 Vue 组件或者全局注册一个 Vue 组件，因为这种姿势忒 low 了！

1）用 JS 对象

``` js
export default { data, props, methods, created, ...}
```

2）用 TS 类 `<script lang="ts">`

``` ts
 @Component
 export default class XXX extends Vue{
     xxx: string = 'hi';
     @Prop(Number) xxx: number|undefined;
 }
```

3）用 JS 类 `<script lang="js">`

``` js
 @Component
 export default class XXX extends Vue{
     xxx = 'hi'
 }
```

> 也可以用 `class` 姿势来写单文件组件！

4）用哪个？

优先使用最难的 TS 姿势！ -> 因为使用最难的，会学到更多的知识！

最简单的姿势是用「用 JS 对象」

注意：你使用了 `class` 组件，那么你就得写上 `@Component`、`extends Vue`

## ★numberPad 模块

