### ✍️ Tangxt ⏳ 2020-09-06 🏷️ 标签页、标签编辑页

# 10-标签页+标签编辑页

## ★ model.js & model.ts

1）为什么要 MVC 思想重构代码？

因为目前的 [代码](https://github.com/ppambler/vue-morney/blob/a7025fd52629a9637f5b7b8edd1191bb2650319a/src/views/Money.vue)，在数据层面上是很混乱的！

所以我们需要对页面做代码分层 -> 用 MVC 思想过来搞 -> 关于这个思想，你记得越模糊越好！如 `M` 负责数据层， `V` 负责视图层， `C` 负责其它的业务逻辑！

目前代码有视图层 `template` ，也有控制器（一个个更新组件状态的方法），但唯独就是差了个 `Model` ，不过，实际上，我们的 `Money.vue` 是有 `Model` 层面上的代码的！

如：

初始化数据，从数据库里边拿数据：

``` ts
const recordList: Record[] = JSON.parse(
  window.localStorage.getItem("recordList") || "[]"
);
```

保存数据到数据库里边：

``` js
window.localStorage.setItem("recordList", JSON.stringify(this.recordList));
```

> MVC 这个思想可以影响一个前端工程师的整个生涯，因为你只要写网页，那么就会用到 MVC，毕竟它实在是太经典了，而**你写页面，不可能不会用到数据**

2）代码实现

> 如何封装一个`model`？

思路：

![思路](assets/img/2020-09-07-17-32-40.png)

> 我们 `push` 一笔账（ `{}` ）到 `recordList` （ `[]` 结构的表）里边， `@Watch` 是可以 `watch` 到 `recordList` 的变化的！

代码：[Demo](https://github.com/ppambler/vue-morney/commit/431c200d8168fd1961a982ac82a6f5d3007a755f)

3）代码解析

1、本来的做法 `model.js`

创建了一个`model.js` （`src`这个根目录下）-> 把获取数据和保存数据的代码扔进去：

![js 姿势的 model](assets/img/2020-09-08-13-35-22.png)

接下来我们要在 `ts` 里边导入 `model.js`，可是 `ts` 里边真得用 `js`吗？

测试发现，我们不能通过 `import`导入这个`model.js`，因为这种姿势与`ts`不相容！

而用了`require`这种姿势却是可行的！

![require](assets/img/2020-09-08-13-45-25.png)

> `require`一开始是不支持`export defalut xxx`这种`defalut`姿势的，之后为了兼容就导出了带有`defalut`的！

所以，如果你在`require`的时候，就`require('xxx.js').default`这样搞！

而前端界里边有一个大佬**呼吁大家不要用 `export defalut xxx`**，而是用具名的姿势：`export {model}`（就是导入列表姿势啦！） -> 引入的时候就 `require('xxx.js').model`（表示我要这个`xxx`文件里的`model`）

> 可以用析构语法：`const {model} = require('model.js')`

总之，不管你用 `export defalut model` 也好，还是用 `export {model}`也罢，都随你的便！ -> **个人建议用后一种，因为语义性更强！**

> 我们在`ts`里边引入`js` -> 使用导入进来的`model` -> 在用 vscode 写代码时是没有提示它有哪些 API 的！（webstorm 可以猜出`model`的类型信息） -> 这就是为啥不用`model.js`而用`model.ts`的原因！

对了，用了这种姿势，你还得测试一下使用了导入进来的`model`，`Money.vue`是否正常运行！（**一定要测试代码是否正常运行，这一点贼重要**）

小结：不推荐使用 JS，因为这是懦夫行为，当然万不得已你可以这样！

接下来看看，如何把 JS 改写成 TS!

2、`model.ts` 

把`.js`后缀改写成`.ts`后缀 -> 这一步就完成了 99%的工作，剩下的工作就是为变量加`: 类型`了！

🤔：原先代码的失误

我们之前局部定义了一个`Record`类型，但该类型是 TS 默认就有的高级类型，所以我们是不能把天生自带的，定义成自己的

总之，`Record`局部声明你随便改没问题，但全局声明就有问题了，毕竟`Record`这个名字已经被占用了！不然就会冲突

所以我们改成是一个不冲突的名字就可以了，如`RecordItem`

> 由于现在要用`RecordItem`，而之前我们都是用 `Record`的，所以有什么快捷方式能快速让`Record`变为`RecordItem`？ -> 编辑器都提供了一个叫「重构」的功能！

💡：如何让一个自定义类型能在所有文件里边使用？

创建`src/custom.d.ts`-> `ts`发现`.d.ts`这个后缀文件，就知道这是一个全局的声明文件

把需要全局使用的类型声明扔到这个文件里边……

![全局的类型声明](assets/img/2020-09-08-17-40-14.png)

一个小技巧：

![查看类型声明](assets/img/2020-09-08-17-42-54.png)

> 你写到每个`RecordItem`类型都会关联到这个`custom.d.ts`文件！-> 关于`custom`这个名字，不是固定的，你也可以叫`xxx.d.ts`，但是`custom`这个名字语义性更好，表示这是我们自定义的类型！

💡：用了`model.ts`就可以用`import`语法了吗？

当然可以：

``` ts
// Money.vue
import model from "@/model";

// model.ts-> 可以使用默认导出了！
export default model;
```

当然，你也可以用有名字的导出，不过，这就需加`{}`了：

``` ts
// Money.vue
import {model} from "@/model";

// model.ts -> or export model -> 推荐带 {} 导出，因为可以一眼看清楚输出了哪些变量。
export {model};
```

简单区分一下默认导出和有名字导出：

- 默认导出 -> `import`时不需要加`{}`
- 有名字导出-> `import`时需要加`{}`，而且`{}`里的名字要与`export`的名字保持一致！

💡：如何确定`fetch`的返回值类型？或者说整个`model.ts`里边的类型？

![确定类型](assets/img/2020-09-08-18-25-38.png)

随便搞个 `x` 变量，就能得出一个个很长的代码的返回值类型了！

可以看到这是一个`any`类型

有两种姿势可以改变`x`的类型：

![姿势有两种](assets/img/2020-09-08-18-33-51.png)

关于姿势二，注意不要把类型强制错了（出错了，就是你活该！），因为 `tsc` 就是根据你强制出来的类型来判断`JSON.parse()`返回值的类型的！

> TS 很简单，把类型说清楚就完事儿了！-> 说不清楚，那你就用回 JS 吧！

为什么要指定`model.fetch()`的返回值类型？也就是给返回值一个`as xxx`这样的断言？

![TS 自动推测类型](assets/img/2020-09-08-18-39-40.png)

方便了我们之后不用再写`:RecordItem[]`了，不然，每个变量都得写一遍 `:RecordItem[]`……

> 最开始的地方写对了，那么后边用到了就会自动推测，千万不要为了图个方便，就不给`model.fetch()`的返回值一个断言（`as RecordItem[]`），不然，你每次需要用到`model.fetch()`的返回值，都得加上 `:RecordItem[]`

💡：为啥要把 `JSON.parse(JSON.stringify(xxx))` 这个操作也封装到`model.clone`了？

因为搞个副本对象这种需求，有很多种姿势可以做到，而我们并不关心是用哪种姿势做到的，反正你调用一下`model.clone`能完成这种需求就可以了，至于`clone`的背后用了啥，一点都不关心，既然不关心，那就封装一下……这样代码看起来就很语义化了

![封装的意义](assets/img/2020-09-08-18-54-23.png)

> 感觉封装就是为了让我们写的代码语义性更强！更能读懂代码在做什么！-> 你想想 `JSON.parse(……)`好懂，还是`clone()`好懂？-> 就像是你叫「名字」好懂人家叫谁，还是叫「头发短的、小眼睛、大嘴巴」好懂人家叫谁？

后边会把这个`model.ts`给删掉！

## ★Labels.vue 之 HTML

1）需求

> 看着设计稿怼就行了！

![标签页](assets/img/2020-09-09-11-37-45.png)

标签页里的每个标签都是可以 `click` 的，`click`之后就跳到标签的标签的「编辑页」，注意，标签名是不可以重复的（我们没有用`id`来区分所有标签）

点击「新建标签」`button` -> 与 `Money` 页面的「新增标签」功能是完全一样的！

点击「删除标签」`button` -> 回到「标签页」列表

![需求图示](assets/img/2020-09-10-12-18-58.png)

2）标签页面

> 写 HTML -> 写 CSS -> 写 JS

💡：为啥要用一个`span`标签包裹一个文本？

![span](assets/img/2020-09-10-16-12-32.png)

💡：页面的背景色写在哪儿？

写在 `body` 里边！

## ★Labels.vue 之 CSS

1）写 CSS 顺序

1. 文本、icon -> 字体大小
2. 文本所处盒子的`min-height`、`padding`等 -> 有关布局
3. 边框、icon、文本 -> 颜色
4. icon -> 布局
5. button -> 背景色、文本颜色、布局、盒子模型

> 元素上下之间的间距用`padding`，因为`margin`会有塌陷，不过`padding`也会影响`background`的范围……当然也可以结合起来使用！

💡：一个你使用`scss`，但一直误会的点？

![scss 选择器](assets/img/2020-09-10-16-36-51.png)

`&`这个符号的作用，可以把嵌套的写法编译成平级的写法：

``` scss
#main {
  color: black;
  a {
    font-weight: bold;
    &:hover { color: red; }
  }
}
```

编译为

``` css
#main {
  color: black; }
  #main a {
    font-weight: bold; }
    #main a:hover {
      color: red; }
```

如果咩有`&`，那就是存粹的后代选择器了！

总之，**被嵌套的也有可能是爸爸级元素！**

## ★新建标签功能

💡：标签存在哪儿？

之前我们用了一个`model`来专门存储一笔账！而现在要存储的东西是「标签」呀！

为啥要存储标签呢？

我们在`Money.vue`里边是这样写的：

``` js
tags = ['衣', '食', '住', '行', '彩票'];
```

显然，这标签是写死的！不管你新建了多少个标签，页面一刷新，新建的标签都会统统消失掉！

所以我们搞了一个叫 `tagListModel` 的东西

之前，我们只有一个`model`，所以就创建了一个叫`model.ts`文件，而现在还需要`model`，所以现在的目录结构变成这样了：

![model 目录](assets/img/2020-09-10-17-38-25.png)

> 本来文件名是没有后缀`Model`的，但不加后缀的话，在使用的时候会有名字冲突！ -> 所以就随便加了一个后缀！

💡：`tagListModel.ts`如何写？

结构基本与`recordListModel.ts`一样，所以 `clone` 一份 `recordListModel.ts`里边的内容粘贴过来，然后修改就好了！

> 结构很像 -> 意味着重复 -> 之后会试着重构一下，如把这两个`model`合成一个！ -> 而目前我们先把功能完成再说！

💡：每个组件的`template`里边，基本不会出现写死的数据？

![数据有了，动态生成 DOM 结构](assets/img/2020-09-10-17-50-48.png)

💡：往`tagListModel`对象里边封装了很多操作？

如`fetch`（从`localStorage`里边拿到`['11','222']`）、`create`（创建标签，如`'3333'`）、`save`（把`['11','222']`保存到`localStorage`）等这样的操作

💡：对象有个属性`data`，可它的类型该怎么声明呢？

这样做？

![语法](assets/img/2020-09-10-18-02-19.png)

我们想要这个`data`的类型是元素是字符串的数组，而不是元素是对象的数组之类的……

所以，我们搞了个类型声明定义：

``` ts
type tagListModel = {
  data: string[];
  fetch: () => string[];
  create: (name: string) => "success" | "duplicated"; //联合类型
  save: () => void;
};
```

`=>`左边`(name: string)`里边的内容是输入的类型（输入咩有就是一个空的`()`），`=>`右边的`string[]`则是输出的结果的类型 -> `void`是不返回

> 这可不是箭头函数语法哈！

不要问为什么要这样写，因为语法就这样规定的！你看着方方写的代码依葫芦画瓢就行了，下次遇到同样的场景，就照着这个姿势去处理就对了！ -> 当你写多了，你也就感觉也就那样了，这语法没啥奇怪的！

💡：为啥要在`tagListModel`对象里边写个`data`属性？

因为`tagListModel`想自己维护`data`，如果你`Labels`页面想要操作`data`，那么你就得用`tagListModel`提供的 API 来操作！而不是让页面直接操作用户数据！

这种处理，跟`recordListModel`对比是不同的：

![data 处理异同](assets/img/2020-09-10-18-21-45.png)

`tagListModel`这样做的好处：

![好处](assets/img/2020-09-10-18-28-58.png)

> 更像 MVC 了，`Labels`组件的`tags`状态值，只是视图渲染的数据源！而 `C` 则是负责调度`M`去操作`data`

![再一次理解 MVC](assets/img/2020-09-10-18-37-17.png)

> 别忘了数据分为 UI 数据 和 用户数据

💡：方方喜欢把创建的东西`return`回去！

![习惯](assets/img/2020-09-10-18-17-30.png)

💡：用户在创建出来的标签重复了，我们该如何提示用户「标签重复了」？

新手做法：创建 成功/失败 就返回`ture/false` -> 根据返回值提示用户

老手做法（考虑很多）：比如为啥创建失败？需要把失败原因给返回出去！

姿势有两种：

姿势一：

![抛出错，捕获错误](assets/img/2020-09-10-19-12-22.png)

姿势二：

按照方方的经验来说，最好是返回一个数字或者返回一个对象！

如：

- 成功返回`0`
- 失败返回`1、2、3、4、5、6、7、8、9、10` -> `1`表示`name`重复……`2`表示`xxx`错误……

返回数字这种姿势可行，但数字这种姿势语义性不好呀！ -> 很容易遗忘……

所以我们用了字符串姿势来表示错误原因！如返回`'duplicate'`就是重复错误，而`'success'`表示创建成功！

返回对象的姿势是这样的：

``` js
{
  // 错误码
  code: number,
  // 错误码所代表的含义
  message: string
}
```

这种返回值也是 ok 的 -> 为了简单起见，返回字符串！

注意，返回字符串这种姿势，很容易会写错单词，所以我们需要统一规定一下：

![联合类型](assets/img/2020-09-10-19-26-48.png)

当你拼错单词的时候，`tsc`就会爆红：

![为啥要用联合类型](assets/img/2020-09-10-19-31-05.png)

> 联合类型是字符串的子类型 -> 也就是说，不是所有的字符串，而是就那两个字符串！ -> 这是不属于那7大类型里边的其中一个，类似于枚举









