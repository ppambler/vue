### ✍️ Tangxt ⏳ 2020-10-05 🏷️ 列表页

# 13-列表展示怎么做

## ★封装 Tabs，使用 deep 语法

![知识点](assets/img/2020-10-05-17-30-29.png)

1）二次封装

在 `Types` 组件的基础上再封装一层！

代码：[Demo](https://github.com/ppambler/vue-morney/commit/36ad09922fc5443378bfd7f7c8e27c279ec73732)

💡：如何更改子组件的样式？

`/deep/` 与 `::v-deep` 的区别 -> 后者可以被 sass 认出来，而前者则不能！

![deep](assets/img/2020-10-05-17-44-30.png)

> 可以不用 `.x` ！直接 `::v-deep`

![v-deep](assets/img/2020-10-05-18-01-05.png)

> 这个 `v-deep` 的存在，让我们使用组件标签更像是在使用一个原生标签了 -> 在一些组件库里边，我们要改某个组件的样式是需要透过添加 `prop` 来改的！而现在我们只要追加一个 `class-prefix` ，然后写上 CSS 样式就行了！

我们加前缀的目的是让子组件知道我们是用什么类型的样式来处理它：

![前缀](assets/img/2020-10-06-18-03-17.png)

效果：

![效果](assets/img/2020-10-06-18-06-21.png)

💡：如果子组件有多个 `li` ，如何精准选中某个 `li` ？

最佳实践是使用 `classPrefix` ！ -> 子组件的 `template` 里边有多个 `li` ，我们在 `Types` 组件标签上写一个 `class-prefix="zzz"` ！

![样式前缀](assets/img/2020-10-05-17-59-32.png)

用表驱动姿势为元素添加 `class` ：

![表驱动](assets/img/2020-10-05-17-51-16.png)

> ES6 语法 -> `key` 有变量的话，那就用 `[]`
💡：再次强调 `!` & `?` 的意思？

![ts 语法](assets/img/2020-10-05-17-48-09.png)

💡：如何完成「按天」、「按周」、「按月」？

![需求](assets/img/2020-10-05-18-07-54.png)

需要封装一个 `Tabs` 组件！ -> 内容基本与 `Types` 组件一致，只是有 3 个 `tab` 罢了！ -> 需要二次封装 `Types` ！ -> 把组件的内容交给父组件去控制！ -> 总之，我们可以把 `Types` 变为更通用的 `Tabs` ！

属性定义：

![属性](assets/img/2020-10-05-18-29-44.png)

变量的起名：

![变量名](assets/img/2020-10-05-18-41-44.png)

改名时，可以用 webstorm 提供的重构功能！ -> 变量名改完后要测试一下，看看能否正常运行！

💡：写 `v-for` 必须加 `key` ，这是潜规则！

💡：加 `class` 的代码好长？

![class](assets/img/2020-10-05-18-36-39.png)

class 封装处理：

![封装](assets/img/2020-10-05-18-37-53.png)

除了函数姿势，你也可以写成是一个 `data` 的姿势！ -> 当然，优先使用 `methods` 姿势的！

2）不要 `Types` 组件了

把 `Tabs.vue` 放到 `Money.vue` 里边 -> `Types` 能做的， `Tabs` 也能做！

代码：[Demo](https://github.com/ppambler/vue-morney/commit/ad66dad899baddf1e5e9335c2cd15d1f5c903bc5)

💡：模块化处理 `intervalList` & `typeList`
把一些枚举东西扔到一个目录里边，其它模块文件需要用就直接导入就好了！

![freeze](assets/img/2020-10-06-17-33-17.png)

> 我们无法往这个数组里边 `push` 东西！

原先的做法：让我们无法改变值，也无法改变值的内容

![值与内容](assets/img/2020-10-06-17-35-44.png)

💡：设计稿中的高度？

![高度](assets/img/2020-10-06-17-43-30.png)

> 可以同时有 `class` & `:class` -> 会自动合并，但不能同时用 `class/:class` 、 `class/:class`
优先级处理：

![优先级](assets/img/2020-10-06-17-48-34.png)

但这有问题呀！我们无法确定这是不是 `li` 元素，万一是 `div` 呢？

那如果加 `!important` 呢？ -> 这是万不得已的做法！

另一种做法，降低组件内部的优先级：

![降低优先级](assets/img/2020-10-06-17-53-44.png)

> 我没有想到 `scss` 这种 `&-item` 语法的结果居然直接 `.tabs-item` 了，而不是 `.tabs > .tabs-item`
这是方方的经验之谈……

对了， `::deep` 的编译结果居然是这样的：

![::deep 编译结果](assets/img/2020-10-06-18-10-33.png)

代码：[Demo](https://github.com/ppambler/vue-morney/commit/7b8ed3e244710badcfafb192ef01e06670bfa23d)

## ★用 JS 配置 height

> 方方推荐用之前的 CSS 姿势！

1）试试用 JS 搞 CSS

代码：[Demo](https://github.com/ppambler/vue-morney/commit/7794b79849c740135ccc3b600bf77ce1b55b43b9)

第一步：

``` ts
@Prop({type:String,default:'64'}) height!: string
```

> 必须加 `!` ，不加的话，那么 `tsc` 就会报错说「你要初始化这个 `height` 」 -> 可这个 `height` 是外边传过来的呀！ -> 所以初始化你妹啊！

第二步：

![css](assets/img/2020-10-06-19-01-31.png)

第三步（使用）：

![使用](assets/img/2020-10-06-19-03-03.png)

---

更改子组件的样式 -> 我们要么传属性，要么写 CSS！ -> 推荐写 CSS

对了， `::deep` 可以优化成这样（不用写两次 `::deep` 了）：

``` scss
::v-deep {
  .type-tabs-item {
    background: white;
    &.selected {
      background: #c4c4c4;
      &::after {
        display: none;
      }
    }
  }

  .interval-tabs-item {
    height: 48px;
  }
}
```

## ★用列表展示数据

1）需求 & 思路

我们要做的：

![需求](assets/img/2020-10-08-13-15-08.png)

用数据结构的思维去分析列表展示，它就是一颗无根之树，也就是所谓的森林：

![森林](assets/img/2020-10-08-13-07-45.png)

那么如何表示森林呢？

很简单，搞一个数组，里边的一个个元素是一个个对象：

![数组 & 对象](assets/img/2020-10-08-13-12-44.png)

公式：

![公式](assets/img/2020-10-08-13-17-26.png)

> `1 + 2 = 3` -> 就是在计算，所以就可以联想到「计算属性」了！

由于自身的数据结构不太好，抽象能力不太好，我们可以用其它奇奇怪怪地方式得到森林，但最最简单的方式还是用计算属性！

2）实现需求

💡：拿到 `recordList` ，就分组？

![分组](assets/img/2020-10-08-13-24-40.png)

💡：关于时间， `ISO 8601` ？

每个前端都要懂！但 99% 的前端都不懂！

💡：这行代码： `(this.$store.state as RootState).recordList` ？

为什么要用 `as RootState` ？ -> 不用的话， `recordList` 就是 `any` 类型了，我们想要的是 `RecordItem[]` ！

这是 TS 与 Vue2 配合的 bug！

💡： `Date` 类型？

![Date](assets/img/2020-10-08-13-32-25.png)

我们存到本地数据库边，是经过一层序列化的操作的，也就是 `JSON.stringify(state.recordList)` ，而当我们：

``` ts
{
  fetchRecords(state) {
    state.recordList = JSON.parse(
      window.localStorage.getItem("recordList") || "[]"
    ) as RecordItem[];
  }
}
```

拿数据的时候，是透过 `JSON.parse` 拿的！而它的返回值是 `any` 类型，然后被我们强制成了 `RecordItem[]` 类型！

JSON 不支持 `Date` 类型，面对`Date`，会转化成 `string`：

![string](assets/img/2020-10-08-13-39-08.png)

所以我们拿到`createdAt`的值时，它就是个 `string` 值，而不是我们声明的 `Date` 类型 -> 我们强制断言`JSON.parse()`的结果是`RecordItem[]`类型，但这只是骗过了 `tsc` 的检查，当代码运行的时候，我们才确切知道 `createdAt` 的结果居然是个 `string`！而不是我们以为的 `Date`！

![Date & string](assets/img/2020-10-08-13-42-22.png)

于是我们把`createdAt`类型改成`string`了：

``` ts
type RecordItem = {
  tags: string[];
  notes: string;
  type: string;
  amount: number; // 数据类型 object | string
  createdAt?: string; // 类 / 构造函数
};
```

因此，之前用到 `createdAt`的地方都得`toISOString()`这样一下：

``` ts
record2.createdAt = new Date().toISOString();
```

> `tsc`即便检查到类型错误，也会让代码在浏览器里边正常地运行起来！

有很多`toXxxString`的 API，我们只要 `ISO 8601` 的 `String`！

💡：如何声明一个空对象`{}`的类型？

``` ts
type HashTableValue = { title: string; items: RecordItem[] };
const hashTable: { [key: string]: HashTableValue } = {}
```

这个`key`可以是`Key`，也可以是`中文`等…… -> 名字随便！ -> `value`值就直接写类型就好了，不用`[value: { title: string }]`这样

![数据](assets/img/2020-10-08-15-14-56.png)

💡：计算属性的执行时机要比`mounted`早！

所以我们用了`beforeCreate`这个钩子！

## ★可抄袭：添加 CSS

代码：[Demo](https://github.com/ppambler/vue-morney/commit/1118251bf52ba77f2d84225ba054306aabd3077d)

💡：`localStorage`最多存 5 M 到 10 M 的数据？

如果数据多了，我们会如何处理呢？ -> 数据库版……

每次只加载 7 天的数据，滚动一下，再加载 7 天的数据

## ★ISO8601 和 dayjs

