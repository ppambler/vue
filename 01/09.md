| ✍️ Tangxt | ⏳ 2020-07-20 | 🏷️ MVC、单向绑定 |

# 09-MVC 与单向绑定

## ★Vue 代替 Controller

1）双向绑定

* 用户 -> 内存：用户通过 `input` 框输入数据，更改内存里边 `data` 旗下的 `n` 值
* 内存 -> 用户：JS 通过修改 `n` ，改变页面视图里 `input` 框里边的值！ -> 手段 `Object.defineProperty`
Vue 做的双向绑定是借鉴 Angular 的，而 Angular 则是借鉴 C#的 WPF（最早把双向绑定投入到大规模的使用中）

> DOM 与 内存的关系

用代码说明一下：

``` html
<div id="app">
  <input type="text" v-model="n">
</div>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
  let vm = new Vue({
    el: '#app',
    data: {
      n: 1
    }
  })
  console.log(vm.n)
  setTimeout(() => {
    console.log(vm.n)
  }, 5000)
</script>
```

![双向绑定](assets/img/2020-07-20-22-47-49.png)

> 改 DOM 自动映射到内存，改内存自动映射到 DOM

2）局部更新

哪个数据变了，就改哪里，而不是整个视图不管数据变没变，都改一遍……

总之，这不是无差别更新……而是有差别攻击……

3）Vue 没有提供 `model` API，但提供了处理 `events` 的 API

为啥没有做呢？ -> 因为没有必要哈！

MVC 搞到最后，只有一个 View 了 -> 为啥会这样呢？ -> 因为 Vue 的功能太多了

很多前端其实看不出 Vue 的 MVC 是在哪儿的……

4）`model`有个`data`，`vue`也有一个`data`，为何不二合一呢？

`data` 的设计是：

``` js
{
  data: {
    // 数据库 数据
    book: {
      id: null,
      name: '未命名',
      number: 0
    },
    n: 1 // -> UI 数据 （也叫用户数据） -> 服务于 input 元素等
  }
}
```

> 本来`model.data`是数据库数据，而`vue.data`是 UI 数据 -> 方方说`book`之外的数据都是 UI 数据

额……我在想，不管是`book`还是`n`都是 UI 数据吧！只是前者的数据源来自于数据库，而后者是来自于用户的！而它们都被渲染到 UI 中……所以说它们都是 UI 数据也不过分吧？

5）小结

- 通过 Vue 的引用，实现了：
  - 把 `controller` 弄到 `methods` 里边去了，还混到模板 HTML 里边去了
  - 把 `model.data` 给干掉，交给 Vue 的 `data` 来存！
- Vue 的名字虽然叫 View，但它实际上做了很多 Controller 和 Model 的事情，当然 Controller 的事情巨多……
- 知道了双向绑定是什么，以及知道了是如何逐渐演化成了`Vue`（**代码组织形式一次比一次好，从例1到例7可以看出，注意，知道每次变化是为什么，是很重要的，对了，这是一年的前端变化哦！方方用一节课的时间就介绍完了，所以很难理解也是很正常的！**） -> MVC 中的 `V` 做了那么多的事情，其实这是有点反 MVC 的，但现在的前端好像也不太在意哈！ -> 反正用了 Vue 之后，这代码组织结构也是极其的好，阅读性也是极其的好……
- 一定要区分数据是来自于服务器的？还是存粹的UI数据？ -> **额，好像来自数据库的数据就是用户数据，如`book`，而像`n`这样的则是 UI 数据，也叫临时数据！这与之前的理解是矛盾的……**

> 想起当初第一次接触MVC的时候，看了半个多月都不怎么懂，而当时，方方就说不能理解那就跳过，过几个月之后，你再看就很容易明白为啥要这样干了……事实证明，确实如方方所说的那样……

## ★单向绑定

> 讲 React 单向绑定的基本思路，不讲 React API

1）信息点

- 一个组件就是一个MVC
- Vue的双向绑定是组件内的，父组件与子组件之间是不能做双向绑定的！
- React 返回一个模板必须要有 `()`，不然就会直接返回一个`undefined` -> 模板语法是`{}`
- 渐进式
  - 白话点来说，第一天你最多吃10个馒头，吃11个就揍你；第二天你最多吃9个馒头，吃10个就揍你……直到某一天一个馒头都不准你吃……
  - Vue，从 `MVC -> M Vue C -> M Vue -> Vue`（对新手来说，是可以接收的，因为这是一点一点过来的哈！）
- 断崖式
  - MVC -> React（直接到React，很突兀，对老手来说是可以接受的）
- 为什么需要单向数据流？
  - 有组件A（`data:{user:{name:'xxx',email:'1@xx.com'}}` -> 渲染用户名）、组件B（`data:{user:{name:'xxx',email:'1@xx.com'}}` -> 渲染用户邮箱） -> 双向绑定，`B`输入新邮箱地址，而`A`的`email`还是旧的，同样，`name`也是如此 -> 为啥不把它们合并成一个组件呢？ -> 假如还要引入很多个组件，那么这综合起来的组件，其`data`就很大了！而这就很不模块化了……
  
  ![React组件](assets/img/2020-07-21-13-59-54.png)
  
  - 所以，我们可以搞个父组件`F`，把`A`和`B`的`data`给删咯！在`F`里创建一个`data:{user:{name:'xxx',email:'1@xx.com'}}` -> 每次用户往`A`的`input`里边输入`name`，那么就会通知`F`组件更新其`data.user.name`，然后再把最新的`name`数据交给`A`去渲染视图……
- React的渲染：
  - 第一次渲染：初始化的`this.state = {book:{},n:1}` -> `render()`
  - 第二次渲染：`this.setState({book:response.data})`（智能的，只会处理那个变化了的状态） -> `render()`
- React的单向是这样的：
  - `state` -> `render()` -> `view`（`input`框里的默认值`1`） -> 用户往`input`框了输入内容（如`12`） -> 触发`change()`事件 -> `update state` -> `render()` -> `view`（`input`框里的值`12`）
  - 注意，如果咩有`change`事件等，是无法输入内容的，因为`input`里的值是来自于`state`的，你不改变`state`的值，那么就不会重新渲染，总之，`state`是多少，那么`render`出来的`view`上的数据就是多少……有种`state`是与`view`绑定的感觉，但这种绑定是单向的…… -> 说白了，React的视图是**只读的**，要更新视图，需要通过一个**事件**来搞 -> **智能的局部更新，即只改某个`state`变了的的那部分**
  
  ![单向](assets/img/2020-07-21-13-15-39.png)
  
- 我感觉只是`v-model`给人的感觉才是实现了双向绑定……因为`v-model`是语法糖呀！它的本质也是监听了视图里的数据变化，然后修改`data`旗下的`n`值，然后再去`render`的！而 React 则是直接的、存粹的、无糖的…… -> 对了，Vue的跨父子组件的双向绑定可以用`.sync`来搞（数据是`prop`，本质也是事件监听……）……
- 单向绑定：半自动的双向绑定；双向绑定：全自动的双向绑定！
  
  ![单向绑定](assets/img/2020-07-21-17-39-12.png)
  
  - 全自动并不是说一定是很好的，这就像是人工智能一样，它大于等于人工智障，因为如果你做得不能特别的善解人意的话，那么这跟智障有区别吗？就像是双向绑定这样，如果不能做到100%完美的双向绑定，还不如搞个半自动呢，因为这样自己的心理倒还是可以接收的哈！总之，不是双向绑定不行，而是**我们很难猜透这样做了的心思**，总之，全自动洗衣机不一定要比半自动洗衣机好！
- 关于`this.add.bind(this)`，为啥总是要加`bind`呢？ -> 一开始React其实不用让你加`bind(this)`的，而是自动加的，然而一些前端用了一段时间之后，就反对这种方式了，这理由跟我们不使用双向绑定差不多，即这样自动的话，有时会显得很智障，还不如让我们全部自己写呢？请不要画蛇添足好吧！总之，反对思路是「全自动不如我半自动，而且全自动还有bug呢！」所以，React在下一个版本就放弃加`bind`了，都让开发者自己加`bind`，那么何时加`bind`？函数不需要`this`，那就不加`bind`呗！但正常情况下，一般都会加上的！ -> 还有`this.add`也没有省略这个`this`，虽然代码理解起来简单了，但似乎又有点啰嗦……
- 先更新UI再更新数据库，如果数据库没有更新到，再撤销UI，还是先更新数据库再更新UI？
  - 前者可以欺骗用户我们的网站性能很快，用户体验很好，但有风险，那就是假如网不好呢？
  - 后者就是稳妥的……
  - 举例子来说，女生喜欢花言巧语，不管能不能成都说成的男生，还是稳妥的不确定的男生？ -> 女生一般喜欢前者的，而程序员也喜欢前者的……
  - React有个专有名词「乐观主义UI」，即先告诉用户成功了，之后如果因网络不好的话，就告诉用户不成功，刚才是我瞎说的…… -> 这种方式主流的方式
  - 你学前端越学到后面，越像是在选择相信哪一种思维，而不是代码怎么写的问题，如你是相信vue、angular的双向绑定，还是更愿意相信React 的单向绑定更可靠呢？ -> 这个得凭自己的经验去做，没有人会告诉你哪个是正确的……
- 组件化的双向绑定因为不好，因为这会让我们总是**倾向于把整个页面变成一个组件**，这样双向绑定起来就会很爽了，但这样就反「组件化」了！ -> 所以推荐最佳实践：
  - 用户数据 -> 单向绑定
  - UI数据 -> 双向绑定
  - 保存在MySQL里面的数据就是用户数据，反之，不存在的，就是UI数据 -> 如用户的邮箱和账号肯定是存在MySQL，所以这是用户数据，所以对于这些数据我们不能用双向绑定，因为如果出现两个地方改它的话，那就很麻烦了…… -> UI数据，这个按钮是显示还是隐藏？这些数据不存储在数据库，而且只有当前这一个组件需要用到，所以为何不用双向绑定呢？（点击，`n`为`1`显示，再点击，`n`为`2`隐藏）反正这些数据不会影响到其它组件！
  - 总之，它们俩适用于不同的场景……

2）React —— 单向绑定

3）单向绑定的要点

1. 单向
2. VirtualDOM

Q：请说一下你对单向绑定的理解？

举栗子说明，如：

1. 上边那个例子代码，纯单向数据流的例子，这种姿势回答很朴素，如果是面对面的面试，可以当着面试官的面来解释这个代码，而这样做是最好的，但很多情况下，这个条件达不到哈！
2. 直接使用一个单向数据流的库来回答这个问题

选择2：

当面试官问你「你是如何理解单向数据流的？」

第一句话就说：`redux`的单向数据流是怎么做的？

找一张图 -> 需要理解很多`redux`的理念

![redux](assets/img/2020-07-21-19-28-54.png)

> 搞清楚MVC之后，正确的代入到图中的饺子（框框的内容）

![redux](assets/img/2020-07-21-19-34-34.png)

Q：面试官问你，请说一下你是如何理解虚拟DOM的？

虚拟DOM就是对DOM的底层封装，我们不用直接去操作DOM，只要告诉虚拟DOM最新的状态是什么，那么虚拟DOM自己就会去更新DOM的一部分……

虚拟DOM最大的优点就是：它可以根据两次数据变化去局部更新

了解：[如何理解虚拟DOM? - 知乎](https://www.zhihu.com/question/29504639)

4）双向绑定的要点

1. 实现方式
   1. Dirty Checking（AngularJS 1.x）的方式
   2. Reactive
      1. 使用 getter setter，缺点是无法监听不存在的属性
      2. 使用 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)

Q：「双向绑定的实现方式？」

![双向绑定](assets/img/2020-07-21-20-17-39.png)

> 原因应该是我们怎么知道`data.name = 'Jack'`这段代码是去改 `input` 呢？

有三种姿势：

1、Dirty Checking（AngularJS 1.x） -> 就是 回调 哈！

AngularJS 1.x 的姿势是「在每次代码变动的时候，给你封装一个东西」

如你第一次初始化：

``` js
{ 
  data: {
    name: 'xxx'
  }
}
```

angular就会去调用`render()`

那如果我第二次修改`data`呢？如使用一个`setTimeout`，`xx`s后 `data.name = 'Jack'`？

但angular并不能发现你是在更改`input`呀！

于是angular想了这么一个办法，不要用`setTimeout`，而是用我封装好的`$setTimeout`（angular提供的一个函数）

`$setTimeout`的功能跟`setTimeout`的功能完全一样，可既然完全一样，为啥还要写呢？ -> 因为它会让`data.name = 'Jack'`执行完之后，调用`render`

那么`render`它会做什么呢？ -> 它会看你的数据与上一次数据有什么不同？

简单来说，angular1.x 能在所有操作`data`的话， 都封装一个函数哈！





