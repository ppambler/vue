| ✍️ Tangxt | ⏳ 2020-07-20 | 🏷️ MVC、单向绑定 |

# 09-MVC 与单向绑定

## ★Vue 代替 Controller

1）双向绑定

* 用户 -> 内存：用户通过 `input` 框输入数据，更改内存里边 `data` 旗下的 `n` 值
* 内存 -> 用户：JS 通过修改 `n` ，改变页面视图里 `input` 框里边的值！ -> 手段 `Object.defineProperty`
Vue 做的双向绑定是借鉴 Angular 的，而 Angular 则是借鉴 C#的 WPF（最早把双向绑定投入到大规模的使用中）

> DOM 与 内存的关系

用代码说明一下：

``` html
<div id="app">
  <input type="text" v-model="n">
</div>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
  let vm = new Vue({
    el: '#app',
    data: {
      n: 1
    }
  })
  console.log(vm.n)
  setTimeout(() => {
    console.log(vm.n)
  }, 5000)
</script>
```

![双向绑定](assets/img/2020-07-20-22-47-49.png)

> 改 DOM 自动映射到内存，改内存自动映射到 DOM

2）局部更新

哪个数据变了，就改哪里，而不是整个视图不管数据变没变，都改一遍……

总之，这不是无差别更新……而是有差别攻击……

3）Vue 没有提供 `model` API，但提供了处理 `events` 的 API

为啥没有做呢？ -> 因为没有必要哈！

MVC 搞到最后，只有一个 View 了 -> 为啥会这样呢？ -> 因为 Vue 的功能太多了

很多前端其实看不出 Vue 的 MVC 是在哪儿的……

4）`model`有个`data`，`vue`也有一个`data`，为何不二合一呢？

`data` 的设计是：

``` js
{
  data: {
    // 数据库 数据
    book: {
      id: null,
      name: '未命名',
      number: 0
    },
    n: 1 // -> UI 数据 （也叫用户数据） -> 服务于 input 元素等
  }
}
```

> 本来`model.data`是数据库数据，而`vue.data`是 UI 数据 -> 方方说`book`之外的数据都是 UI 数据

额……我在想，不管是`book`还是`n`都是 UI 数据吧！只是前者的数据源来自于数据库，而后者是来自于用户的！而它们都被渲染到 UI 中……所以说它们都是 UI 数据也不过分吧？

5）小结

- 通过 Vue 的引用，实现了：
  - 把 `controller` 弄到 `methods` 里边去了，还混到模板 HTML 里边去了
  - 把 `model.data` 给干掉，交给 Vue 的 `data` 来存！
- Vue 的名字虽然叫 View，但它实际上做了很多 Controller 和 Model 的事情，当然 Controller 的事情巨多……
- 知道了双向绑定是什么，以及知道了是如何逐渐演化成了`Vue`（**代码组织形式一次比一次好，从例1到例7可以看出，注意，知道每次变化是为什么，是很重要的，对了，这是一年的前端变化哦！方方用一节课的时间就介绍完了，所以很难理解也是很正常的！**） -> MVC 中的 `V` 做了那么多的事情，其实这是有点反 MVC 的，但现在的前端好像也不太在意哈！ -> 反正用了 Vue 之后，这代码组织结构也是极其的好，阅读性也是极其的好……
- 一定要区分数据是来自于服务器的？还是存粹的UI数据？ -> **额，好像来自己数据库的数据就是用户数据，如`book`，而像`n`这样的则是 UI 数据，也叫临时数据！这与之前的理解是矛盾的……**

> 想起当初第一次接触MVC的时候，看了半个多月都不怎么懂，而当时，方方就说不能理解那就跳过，过几个月之后，你再看就很容易明白为啥要这样干了……事实证明，确实如方方所说的那样……

## ★单向绑定

> 讲 React 单向绑定的基本思路，不讲 React API

1）信息点

- 一个组件就是一个MVC
- Vue的双向绑定是组件内的，父组件与子组件之间是不能做双向绑定的！
- React 返回一个模板必须要有 `()`，不然就会直接返回一个`undefined`
- 渐进式
  - 白话点来说，第一天你最多吃10个馒头，吃11个就揍你；第二天你最多吃9个馒头，吃10个就揍你……直到某一天一个馒头都不准你吃……
  - Vue，从MVC -> M Vue C -> M Vue -> Vue（对新手来说，是可以接收的，因为这是一点一点过来的哈！）
- 断崖式
  - MVC -> React（直接到React，很突兀，对老手来说是可以接受的）
- 为什么需要单向数据流？
  - 有组件A（`data:{user:{name:'xxx',email:'1@xx.com'}}` -> 渲染用户名）、组件B（`data:{user:{name:'xxx',email:'1@xx.com'}}` -> 渲染用户邮箱） -> 双向绑定，`B`输入新邮箱地址，而`A`的`email`还是旧的，同样，`name`也是如此 -> 为啥不把它们合并成一个组件呢？ -> 假如还要引入很多个组件，那么这综合起来的组件，其`data`就很大了！而这就很不模块化了……
  
  ![React组件](assets/img/2020-07-21-13-59-54.png)
  
  - 所以，我们可以搞个父组件`F`，把`A`和`B`的`data`给删咯！在`F`里创建一个`data:{user:{name:'xxx',email:'1@xx.com'}}` -> 每次用户往`A`的`input`里边输入`name`，那么就会通知`F`组件更新其`data.user.name`，然后再把最新的`name`数据交给`A`去渲染视图……
- React的渲染：
  - 第一次渲染：初始化的`this.state = {book:{},n:1}` -> `render()`
  - 第二次渲染：`this.setState({book:response.data})`（智能的，只会处理那个变化了的状态） -> `render()`
- React的单向是这样的：
  - `state` -> `render()` -> `view`（`input`框里的默认值`1`） -> 用户往`input`框了输入内容（如`12`） -> 触发`change()`事件 -> `update state` -> `render()` -> `view`（`input`框里的值`12`）
  - 注意，如果咩有`change`事件等，是无法输入内容的，因为`input`里的值是来自于`state`的，你不改变`state`的值，那么就不会重新渲染，总之，`state`是多少，那么`render`出来的`view`上的数据就是多少……有种`state`是与`view`绑定的感觉，但这种绑定是单向的…… -> 说白了，React的视图是**只读的**，要更新视图，需要通过一个**事件**来搞 -> **智能的局部更新，即只改某个`state`变了的的那部分**
  
  ![单向](assets/img/2020-07-21-13-15-39.png)
  
- 我感觉只是`v-model`给人的感觉才是实现了双向绑定……因为`v-model`是语法糖呀！它的本质也是监听了视图里的数据变化，然后修改`data`旗下的`n`值，然后再去`render`的！而 React 则是直接的、存粹的、无糖的…… -> 对了，Vue的跨父子组件的双向绑定可以用`.sync`来搞（数据是`prop`，本质也是事件监听……）……

2）React —— 单向绑定



